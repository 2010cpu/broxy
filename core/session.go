package core

import (
	"encoding/pem"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"

	"github.com/therecipe/qt/widgets"
)

var globalSettingsFileName = "global_settings.xml"

// Session represents a running session in Broxy with a GUI and loaded modules
type Session struct {

	// represent the session on FS
	Path string

	// List of modules
	Controllers []ControllerModule

	// Logs
	Logs []Log

	MainGui *Broxygui
	Config  *Config

	LogC chan Log

	QApp *widgets.QApplication
}

// NewSession creates a new session
func NewSession(path string, qa *widgets.QApplication) *Session {

	cfg := loadGlobalSettings(path)

	return &Session{
		Path:    path,
		MainGui: NewBroxygui(nil, 0),
		Config:  cfg,
		LogC:    make(chan Log),
		QApp:    qa,
	}
}

func loadGlobalSettings(path string) *Config {

	// if path doesn't exists, create it
	if _, err := os.Stat(path); os.IsNotExist(err) {
		os.MkdirAll(path, 0700)
	}

	var cfg *Config
	xmlSettingsPath := filepath.Join(path, globalSettingsFileName)
	xmlSettingsFile, err := os.Open(xmlSettingsPath)
	defer xmlSettingsFile.Close()
	if err != nil {
		// create the file and put in a new fresh default settings
		cfg = initGlobalSettings()
		saveGlobalSettings(cfg, xmlSettingsPath)
		return cfg
	}

	byteValue, err := ioutil.ReadAll(xmlSettingsFile)
	if err != nil {
		fmt.Println(err)
	}

	err = xml.Unmarshal(byteValue, &cfg)
	if err != nil {
		cfg = initGlobalSettings()
		saveGlobalSettings(cfg, xmlSettingsPath)
	}

	return cfg

}

func initGlobalSettings() *Config {
	// generate a new CA
	// TODO: handle error generated by CreateCA
	rawPvt, rawCA, _ := CreateCA()
	pemPvt := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: rawPvt})
	pemCA := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: rawCA})
	cfg := &Config{
		CACertificate: pemCA,
		CAPrivateKey:  pemPvt,
	}
	return cfg
}

func saveGlobalSettings(cfg *Config, path string) error {
	xmlSettings, _ := xml.MarshalIndent(cfg, "", " ")
	return ioutil.WriteFile(path, xmlSettings, 0700)
}

// LoadModule loads a module in the current session
func (s *Session) LoadModule(c ControllerModule) {
	s.Controllers = append(s.Controllers, c)
	s.MainGui.AddGuiModule(c.GetGui())
}

// Exec executes, for a given module m, a function f with parameters a
func (s *Session) Exec(c string, f string, a ...interface{}) {
	for _, ctrl := range s.Controllers {
		if c == ctrl.GetModule().Name() {
			ctrl.ExecCommand(f, a...)
		}
	}
}

// Info logs an information message in the current session
func (s *Session) Info(mod string, message string) {
	t := time.Now()
	l := Log{Type: "I", ModuleName: mod, Time: t.Format("2006-01-02 15:04:05"), Message: message}
	s.Logs = append(s.Logs, l)
	go func() { s.LogC <- l }()
}

// Debug logs a debug information messasge in the current session
func (s *Session) Debug(mod string, message string) {
	t := time.Now()
	l := Log{Type: "D", ModuleName: mod, Time: t.Format("2006-01-02 15:04:05"), Message: message}
	s.Logs = append(s.Logs, l)
	go func() { s.LogC <- l }()
}

// Err logs an error information message in the current session
func (s *Session) Err(mod string, message string) {
	t := time.Now()
	l := Log{Type: "E", ModuleName: mod, Time: t.Format("2006-01-02 15:04:05"), Message: message}
	s.Logs = append(s.Logs, l)
	go func() { s.LogC <- l }()
}
